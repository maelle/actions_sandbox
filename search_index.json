[["index.html", "Github actions with R Chapter 1 Introduction 1.1 What are GitHub Actions? 1.2 Extensions 1.3 More information and useful links", " Github actions with R Chris Brown, Murray Cadzow, Paula A Martinez, Rhydwyn McGuire, David Neuzerling, David Wilkinson, Saras Windecker 2021-04-09 Chapter 1 Introduction 1.1 What are GitHub Actions? GitHub actions allow us to trigger automated steps after we launch GitHub interactions such as when we push, pull, submit a pull request, or write an issue. For example, there are actions that will automatically trigger: continuous integration (CI) messages in response to issues or pull requests rendering/compiling e.g. of rmarkdown, bookdown, blogdowns etc GitHub actions follow the steps designated in a yaml file, which we place in the .github/workflows folder of the repo. We can add these yaml files to our repo either by clicking on a series of steps on GitHub.com, or using wrapper functions provided by the usethis package, depending on which actions you wish to include. We describe both ways here. 1.1.1 Usethis Wrappers Jim Hester is working to add GitHub action functionalities to the development version of the usethis package. To use these functions now, you’ll need to install the development version, as follows: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-lib/usethis&quot;) Two specific GitHub actions related to continuous integration can be implemented with either of the following: usethis::use_github_action_check_release() usethis::use_github_action_check_full() More details are in chapter 2. There are a range of other R actions available in the r-lib library. You can add these example yaml files using the following function (demonstrated here with the check-release action): usethis:::use_github_action(&#39;check-release.yaml&#39;) 1.1.2 Marketplace Actions There are a huge selection of other actions that you can choose from in the Marketplace that automate not only GitHub processes but also programming-language-specific options. To implement these, go to any repo you own and you will find “Actions” on the top menu. Click on “New Workflow” and pick one from the templates provided. In some cases the yaml will need to be modified. More detail on understanding the yaml files can be found in chapter 4. 1.2 Extensions We experimented with setting up continuous integration with a reproducible environment using renv in chapter 5. 1.3 More information and useful links R-specific GitHub actions examples from r-lib use_github_action function and similar functions help documentation Glossary of actions Workflow syntax for GitHub Actions :tada: Now you know what GitHub actions are and where to find more information about them! Note: the r-lib/ghactions repo is deprecated! "],["packageci.html", "Chapter 2 Example workflow to set up continuous integration for packages 2.1 Set up package 2.2 Actions for continuous integration checks 2.3 Triggering actions 2.4 Did it succeed? 2.5 What next?", " Chapter 2 Example workflow to set up continuous integration for packages This is an example workflow to create a package and use GitHub actions to apply continuous integration (CI). CI automatically checks and tests packages upon a git push. Wrappers to implement some GitHub actions are included in the development version of usethis, which can be installed from GitHub using: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-lib/usethis&quot;) 2.1 Set up package 2.1.1 New project, GitHub first The CI GitHub actions require a package that is set up with Git and GitHub. There are some useful instructions for setting up a new project in the happygitwithr book. After setting up the repo in this way, you’ll need to add the infrastructure to turn the project into a package. You can do so, for example, with the following command: usethis::create_package(path = &quot;path_to_project&quot;) 2.1.2 Existing package with GitHub Make sure that you have GitHub set up with your package. Refer to https://happygitwithr.com/ for setting up with an existing project. Existing project and package, GitHub first Existing project and package, GitHub last 2.1.3 Add GitHub links to DESCRIPTION You’ll need to point your package to where your GitHub instance is located. The following function populates the URL and BugReports fields of a GitHub-using R package DESCRIPTION file with links to GitHub. If your project is hosted by an enterprise GitHub server, this is where you can specify that in the input arguments. usethis::use_github_links() If a new GitHub Personal Access Token (PAT) needs to be generated, usethis will print some instructions to the console for you to follow. 2.2 Actions for continuous integration checks Both of the following functions create a yaml file in .github/workflows/ that will trigger a CI check using GitHub actions. They also print the code to copy into your readme to add a badge for CI. 2.2.1 CI release check usethis::use_github_action_check_release() This option is the more simplified check. It only specifies checking on Mac-OSX and on the most recent version of R. If you are happy with these settings, no alterations to the automatically generated yaml are needed. 2.2.2 CI full check usethis::use_github_action_check_full() This option sets up a more comprehensive CI check. It tests the package on Linux, Windows, as well as Mac-OSX operating systems. It also queries dependencies, caches previous installations of them, and evaluates test coverage using codecov. To make the file work as is, a token for codecov must be added to your secrets page. We explain how to do this below! If you are not interested in syncing your package to codecov, this part is not necessary. 2.3 Triggering actions Now git add, commit the changes and push them to your repo and the action will run! On your repository you can see the what actions are running under the “Actions” tab. 2.4 Did it succeed? You can get information about the status of your GitHub action by looking under the actions tab, and once completed, there will be either a green tick or red cross next to the action. By clicking on the action itself while it’s running or after it’s finished you can view the run logs, which can be useful to understand if your action failed. Further information can be found by clicking on a particular action, and there is the option to make this information displayed as a badge on your README by using the create badge button and copying the markdown code into your README.md file. 2.5 What next? Read on to Chapter 4 to get an introduction to the contents of the yaml files. "],["websites-using-pkgdown-bookdown-and-blogdown.html", "Chapter 3 Websites using pkgdown, bookdown, and blogdown 3.1 Create gh-pages branch 3.2 Action to deploy a pkgdown site 3.3 Action to deploy a bookdown site 3.4 Action to deploy a blogdown site", " Chapter 3 Websites using pkgdown, bookdown, and blogdown 3.1 Create gh-pages branch In order to serve html pages through GitHub pages the following needs to be done to create an emtpy gh-pages branch to be used to deploy the html pages created by either pkgdown, bookdown, or blogdown Derived from: https://pkgdown.r-lib.org/reference/deploy_site_github.html First, we need to create an empty gh-pages branch. In bash: git checkout --orphan gh-pages git rm -rf . git commit --allow-empty -m &#39;Initial gh-pages commit&#39; git push origin gh-pages git checkout master 3.2 Action to deploy a pkgdown site To add auto-generating website documentation for a package, we can leverage off pkgdown and add it to an existing package, and then use a GitHub action to auto generate the documentation and deploy it to a GitHub pages site. First, we add the use of pkgdown to the package: usethis::use_pkgdown() Then, we want to add in the github action for pkgdown to automatically add documentation. There is an existing yaml template example in the actions package: usethis::use_github_action(url = &quot;https://raw.githubusercontent.com/r-lib/actions/master/examples/pkgdown.yaml&quot;) The yaml file should be located in .github/workflows/pkgdown.yml and looks like: on: push: branches: master name: Pkgdown jobs: pkgdown: runs-on: macOS-latest steps: - uses: actions/checkout@master - uses: r-lib/actions/setup-r@master - uses: r-lib/actions/setup-pandoc@master - name: Install dependencies run: | Rscript -e &#39;install.packages(&quot;remotes&quot;)&#39; \\ -e &#39;remotes::install_deps(dependencies = TRUE)&#39; \\ -e &#39;remotes::install_github(&quot;jimhester/pkgdown@github-actions-deploy&quot;)&#39; - name: Install package run: R CMD INSTALL . - name: Deploy package run: | Rscript -e &quot;pkgdown:::deploy_local(new_process = FALSE, remote_url = &#39;https://x-access-token:${{secrets.GH_TOKEN}}@github.com/${{github.repository}}.git&#39;)&quot; Now we need to git add and commit the yaml file, and push the changes to GitHub. 3.3 Action to deploy a bookdown site The following yaml template will run bookdown::render_book() on index.Rmd and then deploy the resulting html files onto the gh-pages branch that was created as part of section 3.1. It uses two GitHub secrets (see section 4.2): secrets.EMAIL and secrets.GITHUB_TOKEN. Create the token EMAIL in your personal settings and then copy the value into the secrets settings for the repository. GITHUB_TOKEN is used from Cecilapp v3. GitHub automatically creates a GITHUB_TOKEN secret to use in your workflow. It is an access token that has repository access (which means you can see the settings of the repository). To learn more about its permissions and examples see Github docs About the GITHUB_TOKEN secret. Furthermore, the action also assumes that you are compiling the book to an html format and the output directory is _book. Github action for .github/workflow/deploy_bookdown.yml on: push: branches: - master name: renderbook jobs: bookdown: name: Render-Book runs-on: macOS-latest steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@v1 - uses: r-lib/actions/setup-pandoc@v1 - name: Install rmarkdown run: Rscript -e &#39;install.packages(c(&quot;rmarkdown&quot;,&quot;bookdown&quot;))&#39; - name: Render Book run: Rscript -e &#39;bookdown::render_book(&quot;index.Rmd&quot;)&#39; - uses: actions/upload-artifact@v1 with: name: _book path: _book/ # Need to first create an empty gh-pages branch # see https://pkgdown.r-lib.org/reference/deploy_site_github.html # and also add secrets for a GH_PAT and EMAIL to the repository # gh-action from Cecilapp/GitHub-Pages-deploy checkout-and-deploy: runs-on: ubuntu-latest needs: bookdown steps: - name: Checkout uses: actions/checkout@master - name: Download artifact uses: actions/download-artifact@v1.0.0 with: # Artifact name name: _book # optional # Destination path path: _book # optional - name: Deploy to GitHub Pages uses: Cecilapp/GitHub-Pages-deploy@v3 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: build_dir: _book/ # &quot;_site/&quot; by default email: ${{ secrets.EMAIL }} # must be a verified email This action is performed using two jobs, the first renders html, and the second deploys the html to the gh-pages branch so that it can be viewed using the url &lt;user/org_name&gt;.github.io/&lt;repository_name&gt;. It achieves this by passing an artifact (the _book directory) between jobs. Further information about the action yaml files can be found in chapter 4. To use the above yaml file that is responsible for deploying this book, you can add it to your book using usethis usethis::use_github_action(url = &quot;https://raw.githubusercontent.com/ropenscilabs/actions_sandbox/master/.github/workflows/deploy_bookdown.yml&quot;) 3.4 Action to deploy a blogdown site The github action to deploy a blogdown site is very similar to that of the bookdown action in section 3.3 but runs blogdown::build_site(). There are additional configuration steps beyond using the github action to get the site to be correctly deployed - this is because blogdown uses Hugo and github pages uses Jekyll. It also requires the creation of two GitHub secrets (see section 4.2), GH_PAT and EMAIL. GH_PAT is a personal access token that has at least repository access (which means you can see the settings of the repository). Create the token in your personal settings and then copy the value into the secrets settings for the repository (see section 4.2.1 for more). On an existing blogdown project with git, make sure to add and commit the content you have created, except for public/*. Change the base url in config.toml to baseurl = \"/&lt;repo name&gt;/\". Create the empty file public/.nojekyll and add and commit it. This tells github not to use Jekyll when displaying your pages. Follow the steps to create an orphaned gh-pages branch in Section 3.1. Github action for .github/workflow/deploy_blogdown.yml on: push: branches: - master name: deployblog jobs: blogdown: name: Render-Blog runs-on: macOS-latest steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@v1 - uses: r-lib/actions/setup-pandoc@v1 - name: Install rmarkdown run: Rscript -e &#39;install.packages(c(&quot;rmarkdown&quot;,&quot;blogdown&quot;))&#39; - name: install hugo run: Rscript -e &#39;blogdown::install_hugo()&#39; - name: Render blog run: Rscript -e &#39;blogdown::build_site()&#39; - uses: actions/upload-artifact@v1 with: name: public path: public/ # Need to first create an empty gh-pages branch # see https://pkgdown.r-lib.org/reference/deploy_site_github.html # and also add secrets for a GH_PAT and EMAIL to the repository # gh-action from Cecilapp/GitHub-Pages-deploy checkout-and-deploy: runs-on: ubuntu-latest needs: blogdown steps: - name: Checkout uses: actions/checkout@master - name: Download artifact uses: actions/download-artifact@v1.0.0 with: # Artifact name name: public # optional # Destination path path: public # optional - name: Deploy to GitHub Pages uses: Cecilapp/GitHub-Pages-deploy@v3 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: build_dir: public/ # &quot;_site/&quot; by default email: ${{ secrets.EMAIL }} # must be a verified email This action will build your blogdown site and then add, commit, and push the resultant files in public/ onto your gh-pages branch where they will be viewable at the url &lt;user/org_name&gt;.github.io/&lt;repository_name&gt;. To use the above yaml file in your blogdown blog you can add it using usethis usethis::use_github_action(url = &quot;https://raw.githubusercontent.com/ropenscilabs/actions_sandbox/master/.github/workflows/deploy_blogdown.yml&quot;) "],["understanding-yaml.html", "Chapter 4 So what’s actually going on in the yaml file? 4.1 GitHub action options 4.2 GitHub Secrets", " Chapter 4 So what’s actually going on in the yaml file? Note: you can use .yml or .yaml as extension of your file for your workflow. Let’s explore the yaml code for the first issue message here: click me code name: Greetings on: [pull_request, issues] jobs: greeting: runs-on: ubuntu-latest steps: - uses: actions/first-interaction@v1 with: repo-token: ${{ secrets.GH_TOKEN }} issue-message: &#39;Hi ! there!! thanks for your contribution!, you are awesome! &#39; pr-message: &#39;Hey what an input! please give us a bit of time to review it! We will be in touch soon.&#39; or here https://github.com/ropenscilabs/CIsandbox/blob/master/.github/workflows/greetings.yml. Translated, that says that the workflow action name is ‘Greetings’ and is triggered on pull requests and issues. It will start a job with the name greeting, and will run on a runner called ubuntu-latest. Then, each job has steps (here there is only one) that will pass commands to the runner or call externally-defined actions, possibly passing parameter values to those actions or setting up the environment by defining environment variables. See more about the syntax. 4.1 GitHub action options Change the &lt;customizable bits&gt; as needed: on: push: pull-request: name: &lt;nameyouraction&gt; jobs: render: name: &lt;nameyourjob&gt; runs-on: macOS-latest steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@v1 - uses: r-lib/actions/setup-pandoc@v1 - name: &lt;namestep1&gt; run: Rscript -e &#39;install.packages(&quot;&lt;the package you need&gt;&quot;)&#39; - name: &lt;namestep2&gt; run: Rscript -e &#39;rmarkdown::render(&quot;examples/README.Rmd&quot;)&#39; - name: &lt;namestep3&gt; run: | git commit &lt;some file&gt;.md -m &#39;Re-build &lt;file&gt;.Rmd&#39; || echo &quot;No changes to commit&quot; git push https://${{github.actor}}:${{secrets.GH_TOKEN}}@github.com/${{github.repository}}.git HEAD:${{ github.ref }} || echo &quot;No changes to commit&quot; The on parameter tells GitHub what should trigger this action. In this case, we want to check code whenever it is pushed, or on a pull request. The latter is particularly useful in the case of a CI action because if we’re about to merge code into the master branch, we want it to pass the tests! The name of the action should be something that helps us identify at a glance what the action is doing. This is shown on github.com in the Actions tab of the repository. runs-on tells GitHub what sort of environment should run the job. These environments are called “runners”. GitHub supports Ubuntu, macOS and Windows Server, as well as self-hosted runners. uses allows us to run other actions as part of our action. In this case, we’re calling on actions that are defined in other repositories. The first action checks out the contents of our repository; the second and third then set up R and Pandoc. The remaining steps, each with a name, contain the commands we want to run as part of our action. Here we’re installing the dependencies of our package. (In the R-CMD-check action produced by usethis::use_github_action_check_release() (see section 2.2.1), we install the rcmdcheck package as well—it’s what we use to check the package in our repository—and then we go ahead and do the check by calling the package-checking function it provides.) 4.2 GitHub Secrets GitHub secrets are a way to use values in your yaml that need to remain secret, such as credentials or information you want to keep private. Commonly this would be a GitHub personal access token (GH_PAT) that enables the action to perform operations such as push. These are set under the repository settings menu. 4.2.1 Personal access tokens Personal access tokens can be generated with differing levels of authority. To create one for your account, go to https://github.com/settings/tokens and click “Generate new token”. Then you can copy the value of the token into a secret for your repository so that a GitHub action can be authenticated as you. "],["testing-with-renev.html", "Chapter 5 Testing with a reproducible environment", " Chapter 5 Testing with a reproducible environment We can take testing a step further by setting up an environment that mimics the one we used to train our model and is set up the same way each time. First we need to set up a lockfile for our package that tells R exactly what packages — including the versions — should be used to reproduce this We’ll be using the renv package, but a word of warning first: this package is still under active development, so this information may quickly become outdated. Once you’ve installed renv, open the R project containing your package and run renv::snapshot(). There will be a prompt for your consent to alter some files in your project and system. This function will automatically determine the dependencies used in your package, as well as what packages (and versions) are installed on your system, and will record this information in a lock file. When you open your project in the future, RStudio will automatically load the packages that are recorded in the snapshot, down to the version number. If the specific versions aren’t available, it will download them and install them from source, or using available binaries. Try restarting your R environment to see this happen. We can trigger this behaviour manually with renv::restore(). To learn more about the renv package, read the introductory article. Now we need to configure GitHub actions to use the snapshot we’ve just set up. In the previous action, we used macOS so that we could take advantage of available package binaries for quick installation. I’m going to be using Ubuntu for this to replicate my personal Linux environment, and this means that packages will be installed from source. Here’s the workflow that I’m using. Read through it and see if you can work out what’s going on, and then we’ll go through the finer details: on: [push, pull_request] name: R-CMD-check jobs: R-CMD-check: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@master with: r-version: &#39;3.6.1&#39; - name: Install libcurl run: sudo apt-get install libcurl4-openssl-dev - name: Install renv 0.9.2 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/renv_0.9.2.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Install rcmdcheck 1.3.3 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/rcmdcheck_1.3.3.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Check run: Rscript -e &quot;renv::restore();rcmdcheck::rcmdcheck(args = &#39;--no-manual&#39;, error_on = &#39;error&#39;)&quot; There are a few differences with this workflow: I’ve specified a version of R to install, for better reproducibility. I’ve installing a package for the operating system, libcurl4-openssl-dev. Because we’re installing R packages from source, we need to be sure that our operating system has all of the tools it needs to compile the source files. This particular package is required to use curl within R; this is pretty important, since if you’re doing anything involving the internet, there’s a good chance you’re using curl somewhere. Your specific package may not need this, but I’m including it here as an example of how to run apt-get in GitHub Actions. We’re installing two packages individually here: renv and rcmdcheck. We need renv to restore our lockfile, so we need to specifically install it before we think about package dependencies. Finally, rcmdcheck is not (usually) a package dependency, and we need it to check our package. Note that we’re manually specifying version numbers here for reproducibility. Our final step looks a little different. We’re calling renv::restore(), which automatically handles all of our package dependencies. Then we run rcmdcheck as we did before. On Ubuntu, packages are installed from source. This is much slower; on one of my packages, testing in a reproducible environment on Ubuntu takes 35 minutes, as opposed to 4 minutes. Caching can make life easier, so let’s take a look at that now. The idea behind caching is to record our installed R packages so that, for future runs, we can have them readily available instead of installing from source. In one of my packages, caching decreased testing time from 35 minutes to 4 minutes. GitHub caches last a week, so if you push commits infrequently you may not realise the benefits of caching. We implement caching by adding two steps to the above YAML: We install and use the remotes package to determine the packages that our repository depends upon. We cache our R libraries folder, given by the R_LIBS_USER environment variable, using the hash of the dependencies as the cache key. If the package dependencies change, so too does the hash, and our cache becomes invalid. There’s a third step that GitHub handles automatically — before the job is complete, the cache is created and our installed packages are stored. On future runs, the cache is unpacked. R will see that the packages are installed and won’t install them again from source. You can read more about caching in GitHub actions in the official documentation. An example yaml file is given below: on: [push, pull_request] name: R-CMD-check jobs: R-CMD-check: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - uses: r-lib/actions/setup-r@master with: r-version: &#39;3.6.1&#39; - name: Install libcurl run: sudo apt-get install libcurl4-openssl-dev - name: Query dependencies run: Rscript -e &quot;install.packages(&#39;remotes&#39;)&quot; -e &quot;saveRDS(remotes::dev_package_deps(dependencies = TRUE), &#39;depends.Rds&#39;)&quot; - name: Cache R packages if: runner.os != &#39;Windows&#39; uses: actions/cache@v1 with: path: ${{ env.R_LIBS_USER }} key: ${{ runner.os }}-r-3.6.1-${{ hashFiles(&#39;depends.Rds&#39;) }} restore-keys: ${{ runner.os }}-r-3.6.1- - name: Install renv 0.9.2 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/renv_0.9.2.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Install rcmdcheck 1.3.3 run: Rscript -e &quot;install.packages(&#39;https://cran.r-project.org/src/contrib/rcmdcheck_1.3.3.tar.gz&#39;, repos = NULL, type = &#39;source&#39;)&quot; - name: Check run: Rscript -e &quot;renv::restore();rcmdcheck::rcmdcheck(args = &#39;--no-manual&#39;, error_on = &#39;error&#39;)&quot; "],["contributions.html", "Chapter 6 Community contributions", " Chapter 6 Community contributions As part of this project some community contributions came up! Issue Spontaneous repository issues with setup-r using ubuntu-latest runner to r-lib/actions from @mdneuzerling PR export use_github_action function to r-lib/usethis from @smwindecker PR adds skip_on_gh_actions (resolves #970) to r-lib/testthat from @njtierney "]]
